---
title: "Travel Stress Score (TSS) Construction"
subtitle: "Unweighted Baseline and Data-Weighted TSS* for Notre Dame Women’s Basketball"
author: "Notre Dame WBB Travel Stress Project"
format: gfm
execute:
  echo: true
  warning: false
  message: false
jupyter: python3
---

---

## Executive Summary

This project develops a **Travel Stress Score (TSS)** to quantify the logistical and competitive demands associated with Notre Dame Women’s Basketball travel schedules and to evaluate how those demands relate to on-court performance.

We construct:
- **Unweighted TSS (baseline):** a transparent index that aggregates standardized travel and scheduling stressors plus interaction effects.
- **Weighted TSS\* (data-derived):** a tuned index where both primary factors and interaction terms are **weighted using historical outcomes** (scoring margin) via regression.

The resulting scores provide a practical tool for benchmarking travel demand and supporting evidence-based scheduling and recovery planning.

---

## Key Takeaways

- Travel stress is **multidimensional** (travel time, rest, opponent strength, time zones, home/away context, back-to-backs).
- Interaction effects capture **compounding stress** (e.g., long travel * time-zone shift).
- Data-derived weighting (TSS\*) improves alignment with observed performance variability vs. equal-weight baselines.
- The framework is modular and extensible to other teams, seasons, and outcomes.

---

## Methodology

### Problem framing

We aim to quantify “how demanding” each game’s context is using public travel and schedule information, then evaluate whether higher stress aligns with differences in performance (e.g., scoring margin).

### Index design principles

1. **Directional consistency:** Each component is oriented so higher values represent higher stress.
2. **Comparability:** Continuous inputs are standardized (z-scores) to avoid unit-driven dominance.
3. **Baseline + tuning:** We start with an equal-weight baseline (unweighted TSS), then learn weights from historical outcomes to produce a tuned score (TSS\*).
4. **Compounding effects:** Interaction terms capture situations where combined stressors matter more than either factor alone.

### Inputs used

Primary stress drivers:
- `travel_minutes`
- `Opponent Rank` → transformed so stronger opponents (lower rank) increase stress
- `days_since_last_game` → used only when ≤ 50 days (exclude off-season gaps)
- `road_score`
- `timezone_change`
- `back_to_back` (1 if games are on sequential days)

### Score definitions

**Unweighted baseline TSS**  
\[
\text{TSS}_{unweighted} = \sum(\text{standardized primary factors}) + \sum(\text{standardized interactions})
\]

**Weighted TSS\***  
Weights are learned from a regression using scoring margin as the outcome. Primary and interaction weights are derived from **absolute standardized coefficients** and normalized to sum to 1:
\[
\text{TSS}^* = \sum(w_j\,Z(x_j)) + \sum(w_{ab}\,Z(x_a\,x_b))
\]

---

## 1. Load Libraries and Data

### Plain-English purpose

We load the tooling needed for data preparation, standardization, interaction generation, and regression modeling, then read the final cleaned dataset.

```{python}
# If running in Colab, you can uncomment:
# !pip install openpyxl scipy statsmodels --quiet

import pandas as pd
import numpy as np
from itertools import combinations
from scipy.stats import zscore
import statsmodels.api as sm
```

```{python}
FILE_PATH = "2014-24 Final Data.xlsx"
df = pd.read_excel(FILE_PATH)

print("Loaded dataset:", df.shape)
df.head()
```

---

## 2. Feature Engineering (Stress-Oriented Variables)

We transform raw fields so that “higher = more stress” and create additional indicators needed for the index.

```{python}
# Stronger opponent (lower rank) => more stress
df["opp_rank_stress"] = -df["Opponent_Rank"]

# Ignore unusually long gaps (> 50 days) for rest stress
df["days_stress"] = df["days_since_last_game"].where(df["days_since_last_game"] <= 50, np.nan)

# Back-to-back indicator
df["back_to_back"] = (df["days_since_last_game"] == 1).astype(int)
```

---

## 3. Build Primary Stress Matrix

We isolate the core variables that represent travel/schedule stress and store them in a single table.

```{python}
primary_vars = [
    "travel_minutes",
    "opp_rank_stress",
    "days_stress",
    "road_score",
    "timezone_change",
    "back_to_back"
]

stress_df = df[primary_vars].copy()
stress_df.head()
```

---

## 4. Standardize Continuous Inputs

Continuous variables use different units (minutes, days, etc.). Z-scoring makes them comparable so no single metric dominates due to scale.

```{python}
continuous_vars = ["travel_minutes", "opp_rank_stress", "days_stress", "timezone_change"]

for col in continuous_vars:
    stress_df[col] = zscore(stress_df[col].fillna(stress_df[col].mean()))

stress_df.head()
```

---

## 5. Create and Standardize Interaction Terms

Interaction terms model “compound stress” (e.g., long travel combined with timezone changes). We create pairwise interactions and z-score them.

```{python}
vars_for_interactions = [
    "travel_minutes",
    "opp_rank_stress",
    "days_stress",
    "road_score",
    "timezone_change"
]

interaction_terms = {}
for A, B in combinations(vars_for_interactions, 2):
    interaction_terms[f"{A}_x_{B}"] = stress_df[A] * stress_df[B]

interaction_df = pd.DataFrame(interaction_terms)

for col in interaction_df.columns:
    interaction_df[col] = zscore(interaction_df[col].fillna(interaction_df[col].mean()))

print("Number of interaction terms:", interaction_df.shape[1])
interaction_df.head()
```

---

## 6. Compute Unweighted TSS (Baseline)

The baseline score treats each standardized component as equally important. This provides a transparent benchmark before learning weights.

```{python}
df["travel_stress_score"] = stress_df.sum(axis=1) + interaction_df.sum(axis=1)

df[["game_id", "season", "travel_stress_score"]].head()
```

---

## 7. Compute Weighted TSS\* (Primary Weights from Regression)

We learn data-derived weights for primary stress factors by regressing scoring margin on the standardized predictors. We convert absolute standardized coefficients into normalized weights.

```{python}
reg_y = pd.to_numeric(df["margin"], errors="coerce")

reg_X = stress_df.copy()
for col in reg_X.columns:
    reg_X[col] = zscore(reg_X[col].fillna(reg_X[col].mean()))

reg_data = pd.concat([reg_X, reg_y], axis=1).dropna()
X_primary = sm.add_constant(reg_data[reg_X.columns])
y_primary = reg_data["margin"]

primary_model = sm.OLS(y_primary, X_primary).fit()
print(primary_model.summary())

primary_coefs = primary_model.params.drop("const")
primary_weights = primary_coefs.abs() / primary_coefs.abs().sum()

print("\nPrimary (regression-derived) weights:")
print(primary_weights)

df["weighted_TSS_primary"] = (reg_X[primary_weights.index] * primary_weights).sum(axis=1)
df[["game_id", "season", "weighted_TSS_primary"]].head()
```

---

## 8. Compute Weighted Interaction Contribution (Method 1)

Instead of manually assigning interaction weights, we estimate a regression including both primary and interaction terms, then derive weights from the interaction coefficients.

```{python}
full_X = pd.concat([reg_X, interaction_df], axis=1)
full_data = pd.concat([full_X, reg_y], axis=1).dropna()

X_full = sm.add_constant(full_data[full_X.columns])
y_full = full_data["margin"]

interaction_model = sm.OLS(y_full, X_full).fit()
print(interaction_model.summary())

interaction_coefs = interaction_model.params.drop("const")[interaction_df.columns]
interaction_weights = interaction_coefs.abs() / interaction_coefs.abs().sum()

print("\nTop interaction weights (data-derived):")
print(interaction_weights.sort_values(ascending=False).head(15))

weighted_interactions = (interaction_df * interaction_weights).sum(axis=1)
df["weighted_TSS_full"] = df["weighted_TSS_primary"] + weighted_interactions

df[["game_id", "season", "margin", "travel_stress_score", "weighted_TSS_full"]].head()
```

---

## 9. Export Outputs

We exported a single dataset containing both baseline and weighted scores for reporting and downstream analysis.

```{python}
OUTPUT_XLSX = "2014-24_Final_Data_with_TSS_Unweighted_and_Weighted.xlsx"
df.to_excel(OUTPUT_XLSX, index=False)
print("Saved:", OUTPUT_XLSX)
```

---